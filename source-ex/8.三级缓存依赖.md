# 三级缓存依赖问题

描述：spring容器是用来管理bean的存放与获取的，而循环依赖问题，就是在bean存放与获取的过程中出现的问题。为了解决这个问题，使用了三级缓存来存放处于各个状态中的单例bean对象，最终解决了循环依赖问题。

执行简述：容器检查所有Bean对象是否完成创建 - 容器扫描项目代码，然后检查所有的Bean对象是否创建完成(没有就创建这个bean)，保证所有的bean都创建完成，接下来将所有Bean保存在集合`singletonObjects`
中，并且对使用者提供 getBean 获取对象的方法。

1. spring容器启动，立即开始扫描被指定注解(`@Component,@Service...`)标记的类，将所有扫描到的 类的信息(类名，类属性，类上的注解) 统统存入 `beanDefinitionMap`
   .因此`beanDefinitionMap`就是一个关于bean对象的配置信息集合。
2. 接下来，Spring容器 根据配置集合 `beanDefinitionMap`遍历,尝试从总Bean集合 `singletonObjects`
   中将所有的Bean对象一一取出。如果能够全部取出，那么表示所有Bean对象创建完成，完成检查！如果不能够全部取出，那么则需要创建这个Bean，并存入`singletonObjects`。
3. 例如，`beanDefinitionMap`中第一个配置信息是 `AClass`, 那么对应尝试从 `singletonObjects` 获取对象 `aClass`.
4. 刚开始，一级缓存 `singletonObjects` 没有存放任何对象，肯定找不到，接下来，检查`AClass`是否为空并且是否正处于创建过程中，如果是，那么存入二级缓存中`earlySingletonObjects`
5. 直接 `createBean` 创建一个A的实例 `aClass`, 然后存入一级缓存，然后返回，到此第一个Bean对象 `aClass`实例化完成。
6. 获取到对象A的实例后，将要尝试 注入每一个属性 `populateBean`。如果注入属性成功，那么就直接返回
   检查A的实例是否为空以及是否正在创建中。如果是正处于创建中，那么尝试从二级缓存 `earlySingletonObjects`中获取
7. 在创建B对象时，

-> AClass.class  
-> aClass(初始化开始,存入`singletonsCurrentlyInCreation`，表示正在创建中)
-> aClass 从1级 `singletonObjects` 查找(没找到)
-> 检查 aClass 是否为空并且是否正处于创建(singletonsCurrentlyInCreation)中 -> 是true,从`earlySingletonObjects`查找，没找到 ->
根据beanName,从3级 `singletonFactories` 创建一个 objectFactory 对象，存入2级`earlySingletonObjects`，返回这个 `singletonFactories`

--> 开始注入aClass的属性:bClass

-> aClass.bClass(属性 bClass 是一个bean对象)
-> bClass 是否在`singletonObjects`中，不在 -> 那么，初始化开始,存入`singletonsCurrentlyInCreation`，表示正在创建中 -> bClass
从1级 `singletonObjects` 查找(没找到)
-> 检查 bClass 是否为空并且是否正处于创建(singletonsCurrentlyInCreation)中 -> 是true,从`earlySingletonObjects`查找，没找到 ->
根据beanName,从3级 `singletonFactories` 创建一个 objectFactory 对象，存入2级`earlySingletonObjects`，返回这个 `singletonFactories`

--> 开始注入bClass的属性: aClass

-> bClass.aClass(属性 aClass 是一个bClass的属性)
-> aClass 是否在`singletonObjects`中，不在 -> 那么，初始化开始,存入`singletonsCurrentlyInCreation`，表示正在创建中 -> aClass
从1级 `singletonObjects` 查找(没找到)
-> 检查 aClass 是否为空并且是否正处于创建(singletonsCurrentlyInCreation)中

--> **区别出现,循环到第三次查找发生了变化**
-> 是true,从`earlySingletonObjects`查找，找到了 -> 返回这个 `singletonFactories`

代码流程：

- 当spring扫描所有的Bean对象，并创建好BeanDefinition后，将所有的单例BeanDefinition 存入Map singletonObjects。
- 初始化Bean对象时，首先检测 Bean对象 是否处于创建中,即「还没有执行初始化方法」。比如，A 的构造器依赖了 B 对象因此要先去创建 B 对象，或者在 A 的属性装配过程中依赖了 B 对象因此要先创建 B 对象，这时 A
  就是处于创建中的状态。
- 使用 beforeSingletonCreation() 方法，在初始化之前检测是否处于创建中

- 使用 afterSingletonCreation() 方法，在初始化之后检测是否处于创建中

## 过程

- Spring 会先从一级缓存 `singletonObjects` 中尝试获取 Bean。
- 若是获取不到，而且对象正在建立中，就会尝试从二级缓存 `earlySingletonObjects` 中获取 Bean。
- 若还是获取不到，且允许从三级缓存 `singletonFactories` 中经过 singletonFactory 的 `getObject()` 方法获取 Bean 对象，就会尝试从三级缓存 `singletonFactories` 中获取
  Bean。
- 若是在三级缓存中获取到了 Bean，会将该 Bean 存放到二级缓存中。

## 源码

单例 Bean 的实例、早期单例 Bean 的实例、单例 Bean 工厂 使用三级缓存来解决依赖循环问题(
源代码位于包org.springframework.beans.factory.support中.`DefaultSingletonBeanRegistry`):

```java
public class DefaultSingletonBeanRegistry extends SimpleAliasRegistry implements SingletonBeanRegistry {
    /**
     * 单例池 一级缓存：存放初始化完成的 bean 对象
     **/
    private ConcurrentHashMap<String, Object> singletonObjects = new ConcurrentHashMap<>(256);

    /**
     * 二级缓存：存放原始的 bean 对象（尚未填充属性）
     **/
    private Map<String, Object> earlySingletonObjects = new ConcurrentHashMap<>(16);

    /**
     * 三级级缓存：存放 bean 工厂对象，用于解决循环依赖
     **/
    private Map<String, ObjectFactory> singletonFactories = new HashMap<>(16);


    /**
     * 保存 正处于正在创建中状态的 Bean的名称
     */
    private Set<String> singletonsCurrentlyInCreation = Collections.newSetFromMap(new ConcurrentHashMap<>(16));
}
```

详细步骤解释：

1. getSingleton()

```java
package org.springframework.beans.factory.support;

public abstract class FactoryBeanRegistrySupport extends DefaultSingletonBeanRegistry {

    @Nullable
    protected Object getSingleton(String beanName, boolean allowEarlyReference) {
        Object singletonObject = this.singletonObjects.get(beanName);
        if (singletonObject == null && this.isSingletonCurrentlyInCreation(beanName)) {
            singletonObject = this.earlySingletonObjects.get(beanName);
            if (singletonObject == null && allowEarlyReference) {
                synchronized (this.singletonObjects) {
                    singletonObject = this.singletonObjects.get(beanName);
                    if (singletonObject == null) {
                        singletonObject = this.earlySingletonObjects.get(beanName);
                        if (singletonObject == null) {
                            ObjectFactory<?> singletonFactory = (ObjectFactory) this.singletonFactories.get(beanName);
                            if (singletonFactory != null) {
                                singletonObject = singletonFactory.getObject();
                                this.earlySingletonObjects.put(beanName, singletonObject);
                                this.singletonFactories.remove(beanName);
                            }
                        }
                    }
                }
            }
        }

        return singletonObject;
    }
}
```

### 参考阅读

- [三级缓存依赖](https://juejin.cn/post/7099745254743474212)
- [三级缓存解释](https://www.jianshu.com/p/6cbbb6a9b3fd)