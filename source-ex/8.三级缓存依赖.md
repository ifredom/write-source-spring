# 三级缓存依赖问题

描述：spring容器是用来管理bean的存放与获取的，而循环依赖问题，就是在bean存放与获取的过程中出现的问题。为了解决这个问题，使用了三级缓存来存放处于各个状态中的单例bean对象，最终解决了循环依赖问题。

执行简述：容器检查所有Bean对象是否完成创建 - 容器扫描项目代码，然后检查所有的Bean对象是否创建完成(没有就创建这个bean)，保证所有的bean都创建完成，接下来将所有Bean保存在集合`singletonObjects`
中，并且对使用者提供 getBean 获取对象的方法。

1. spring容器启动，立即开始扫描被指定注解(`@Component,@Service...`)标记的类，将所有扫描到的 类的信息(类名，类属性，类上的注解) 统统存入 `beanDefinitionMap`
   .因此`beanDefinitionMap`就是一个关于bean对象的配置信息集合。
2. 接下来，Spring容器 根据配置集合 `beanDefinitionMap`遍历,尝试从总Bean集合 `singletonObjects`
   中将所有的Bean对象一一取出。如果能够全部取出，那么表示所有Bean对象创建完成，完成检查！如果不能够全部取出，那么则需要创建这个Bean，并存入`singletonObjects`。
3. 例如，`beanDefinitionMap`中第一个配置信息是 `AClass`, 那么对应尝试从 `singletonObjects` 获取对象 `aClass`.
4. 刚开始，一级缓存 `singletonObjects` 没有存放任何对象，因此，直接 `createBean` 创建一个A的实例 `aClass`, 然后存入一级缓存，然后返回，到此第一个Bean对象 `aClass` ，。
5. 获取到对象A的实例后，将要尝试 注入每一个属性 `populateBean`。如果注入属性成功，那么就直接返回
   检查A的实例是否为空以及是否正在创建中。如果是正处于创建中，那么尝试从二级缓存 `earlySingletonObjects`中获取
6. 在创建B对象时，

代码流程：

- 当spring扫描所有的Bean对象，并创建好BeanDefinition后，将所有的单例BeanDefinition 存入Map singletonObjects。
- 初始化Bean对象时，首先检测 Bean对象 是否处于创建中,即「还没有执行初始化方法」。比如，A 的构造器依赖了 B 对象因此要先去创建 B 对象，或者在 A 的属性装配过程中依赖了 B 对象因此要先创建 B 对象，这时 A
  就是处于创建中的状态。
- 使用 beforeSingletonCreation() 方法，在初始化之前检测是否处于创建中

- 使用 afterSingletonCreation() 方法，在初始化之后检测是否处于创建中

## 源码

单例 Bean 的实例、早期单例 Bean 的实例、单例 Bean 工厂 使用三级缓存来解决依赖循环问题(
源代码位于包org.springframework.beans.factory.support中.`DefaultSingletonBeanRegistry`):

```java
public class DefaultSingletonBeanRegistry extends SimpleAliasRegistry implements SingletonBeanRegistry {
    /**
     * 单例池 一级缓存：存放初始化完成的 bean 对象
     **/
    private ConcurrentHashMap<String, Object> singletonObjects = new ConcurrentHashMap<>(256);

    /**
     * 二级缓存：存放原始的 bean 对象（尚未填充属性）
     **/
    private Map<String, Object> earlySingletonObjects = new ConcurrentHashMap<>(16);

    /**
     * 三级级缓存：存放 bean 工厂对象，用于解决循环依赖
     **/
    private Map<String, ObjectFactory> singletonFactories = new HashMap<>(16);


    /**
     * 保存 正处于正在创建中状态的 Bean的名称
     */
    private Set<String> singletonsCurrentlyInCreation = Collections.newSetFromMap(new ConcurrentHashMap<>(16));
}
```

详细步骤解释：

1. getSingleton()

```java
package org.springframework.beans.factory.support;

public abstract class FactoryBeanRegistrySupport extends DefaultSingletonBeanRegistry {

    @Nullable
    protected Object getSingleton(String beanName, boolean allowEarlyReference) {
        Object singletonObject = this.singletonObjects.get(beanName);
        if (singletonObject == null && this.isSingletonCurrentlyInCreation(beanName)) {
            singletonObject = this.earlySingletonObjects.get(beanName);
            if (singletonObject == null && allowEarlyReference) {
                synchronized (this.singletonObjects) {
                    singletonObject = this.singletonObjects.get(beanName);
                    if (singletonObject == null) {
                        singletonObject = this.earlySingletonObjects.get(beanName);
                        if (singletonObject == null) {
                            ObjectFactory<?> singletonFactory = (ObjectFactory) this.singletonFactories.get(beanName);
                            if (singletonFactory != null) {
                                singletonObject = singletonFactory.getObject();
                                this.earlySingletonObjects.put(beanName, singletonObject);
                                this.singletonFactories.remove(beanName);
                            }
                        }
                    }
                }
            }
        }

        return singletonObject;
    }
}
```

### 参考阅读

- [三级缓存依赖](https://juejin.cn/post/7099745254743474212)